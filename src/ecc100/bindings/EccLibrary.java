package ecc100.bindings;

import java.util.Collections;
import java.util.Iterator;

import org.bridj.BridJ;
import org.bridj.CRuntime;
import org.bridj.FlagSet;
import org.bridj.IntValuedEnum;
import org.bridj.Pointer;
import org.bridj.ann.Convention;
import org.bridj.ann.Library;
import org.bridj.ann.Ptr;
import org.bridj.ann.Runtime;

/**
 * Wrapper for library <b>ecc</b><br>
 * This file was autogenerated by
 * <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that
 * <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a
 * few opensource projects.</a>.<br>
 * For help, please visit
 * <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or
 * <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("ecc")
@Runtime(CRuntime.class)
public class EccLibrary
{
  static { BridJ.register(); }

  /**
   * enum values<br>
   * <i>native declaration : lib\ecc100\ecc.h</i>
   */
  public enum ECC_actorType implements IntValuedEnum<ECC_actorType>
  {
   /** < Actor is of linear type */
   ECC_actorLinear(0),
   /** < Actor is of goniometer type */
   ECC_actorGonio(1),
   /** < Actor is of rotator type */
   ECC_actorRot(2);
    ECC_actorType(long value)
    {
      this.value = value;
    }

    public final long value;

    public long value()
    {
      return this.value;
    }

    public Iterator<ECC_actorType> iterator()
    {
      return Collections.singleton(this).iterator();
    }

    public static IntValuedEnum<ECC_actorType> fromValue(int value)
    {
      return FlagSet.fromValue(value, values());
    }
  };

  /** <i>native declaration : lib\ecc100\ecc.h</i> */
  public static final int NCB_NotConnected = (int) 2;
  /** <i>native declaration : lib\ecc100\ecc.h</i> */
  public static final int NCB_DriverError = (int) 3;
  /** <i>native declaration : lib\ecc100\ecc.h</i> */
  public static final int NCB_InvalidParam = (int) 9;
  /** <i>native declaration : lib\ecc100\ecc.h</i> */
  public static final int NCB_Error = (int) (-1);
  /** <i>native declaration : lib\ecc100\ecc.h</i> */
  public static final int NCB_DeviceLocked = (int) 7;
  /** <i>native declaration : lib\ecc100\ecc.h</i> */
  public static final int NCB_Ok = (int) 0;
  /** <i>native declaration : lib\ecc100\ecc.h</i> */
  public static final int NCB_Timeout = (int) 1;
  /** <i>native declaration : lib\ecc100\ecc.h</i> */
  public static final int NCB_FeatureNotAvailable = (int) 10;

  /**
   * @brief Check devices<br>
   *        <br>
   *        Checks whether the USB driver is accessible and how many devices are
   *        connected.<br>
   *        The function returns with a pointer to an array of struct @ref
   *        EccInfo. The return code<br>
   *        tells how many devices were found (and so how many elements the
   *        array contains).<br>
   *        The struct contains information wheteher a device is accessible
   *        (unlocked) or is already<br>
   *        in use by someone else (locked). The device ID is a number
   *        programmed by the user<br>
   *        to distinguish between multiple devices. It is valid only if the
   *        device is unlocked.<br>
   *        <br>
   *        The function must not be called as long as a device is connected
   *        by @ref ECC_Connect.<br>
   *        <br>
   * @param info
   *          Output: Pointer to array of struct 'EccInfo'. The parameter may be
   *          NULL<br>
   *          to ignore the devices array.<br>
   * @return Count of found devices<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_Check(EccInfo**)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:113</i>
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_Check(Pointer<Pointer<EccInfo>> info)
  {
    return ECC_Check(Pointer.getPeer(info));
  }

  @Convention(Convention.Style.StdCall)
  protected native static int ECC_Check(@Ptr long info);

  /**
   * @brief Inquire device properties<br>
   *        <br>
   *        The function provides an alternative (and more labview friendly) way
   *        to<br>
   *        inspect the devices found by @ref ECC_Check . It returns the locking
   *        state<br>
   *        and device ID as provided in the info array of @ref ECC_Check .<br>
   * @param deviceNo
   *          Index of the device, must be smaller than the number of found
   *          devices.<br>
   * @param devId
   *          Output: Device ID, only valid if unlocked.<br>
   * @param locked
   *          Output: Locking state.<br>
   *          Original signature :
   *          <code>__attribute__((dllimport)) Int32 ECC_getDeviceInfo(Int32, Int32*, Bln32*)</code><br>
   *          <i>native declaration : lib\ecc100\ecc.h:126</i>
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_getDeviceInfo(int deviceNo, Pointer<Integer> devId, Pointer<Integer> locked) {
    return ECC_getDeviceInfo(deviceNo, Pointer.getPeer(devId), Pointer.getPeer(locked));
  }

  @Convention(Convention.Style.StdCall)
  protected native static int ECC_getDeviceInfo(int deviceNo, @Ptr long devId, @Ptr long locked);


  /**
   * @brief Release info<br>
   *        <br>
   *        Releases the memory allocated by Ecc_Check for the info array.<br>
   *        Original signature :
   *        <code>__attribute__((dllimport)) void ECC_ReleaseInfo()</code><br>
   *        <i>native declaration : lib\ecc100\ecc.h:134</i>
   */
  @Convention(Convention.Style.StdCall)
  public static native void ECC_ReleaseInfo();


  /**
   * @brief Connect device<br>
   *        <br>
   *        Initializes and connects the selected ECC (0..n).<br>
   *        This has to be done before any other function (except ECC_Check and
   *        ECC_ReleaseInfo) can be called.<br>
   *        The returned handle is used to address the device in further
   *        communication.<br>
   *        <br>
   * @param deviceNo:
   *          Index of the device to connect (0..n)<br>
   * @param deviceHandle:
   *          Pointer to (user)memory which will retrieve the Handle.<br>
   *          <br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_Connect(Int32, Int32*)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:150</i>
   */

  /**
   * Super deep reference to returning some int value from Pointer class
   * @param deviceNo
   * @param deviceHandle
   * @return int>0 if all is alright...
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_Connect(int deviceNo, Pointer<Integer> deviceHandle) {
    return ECC_Connect(deviceNo, Pointer.getPeer(deviceHandle));
  }

  @Convention(Convention.Style.StdCall)
  protected native static int ECC_Connect(int deviceNo, @Ptr long deviceHandle);


  /**
   * @brief Close connection<br>
   *        <br>
   *        Closes the connection to the device.<br>
   *        <br>
   * @param deviceHandle:
   *          Handle of device<br>
   *          <br>
   * @return Result: NCB_Ok (exclusive result value)<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_Close(Int32)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:161</i>
   */
  @Convention(Convention.Style.StdCall)
  public static native int ECC_Close(int deviceHandle);


  /**
   * @brief Control output stage<br>
   *        <br>
   *        Controls the output relays of the selected axis.<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @param axis
   *          Number of the axis to be configured<br>
   * @param enable
   *          Switches the output relais<br>
   * @param set
   *          1: Send the supplied values to the controller<br>
   *          0: Ignore input; only retreive the results<br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_controlOutput(Int32, Int32, Bln32*, Bln32)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:179</i>
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_controlOutput(int deviceHandle,
                                      int axis,
                                      Pointer<Integer> enable,
                                      int set)
  {
    return ECC_controlOutput(deviceHandle, axis, Pointer.getPeer(enable), set);
  }

  @Convention(Convention.Style.StdCall)
  protected native static int ECC_controlOutput(int deviceHandle, int axis, @Ptr long enable, int set);

  /**
   * @brief Control amplitude<br>
   *        <br>
   *        Controls the amplitude of the actuator signal.<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @param axis
   *          Number of the axis to be configured<br>
   * @param amplitude
   *          Amplitude in mV<br>
   * @param set
   *          1: Send the supplied values to the controller<br>
   *          0: Ignore input; only retreive the results<br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_controlAmplitude(Int32, Int32, Int32*, Bln32)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:195</i>
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_controlAmplitude(int deviceHandle, int axis, Pointer<Integer> amplitude, int set) {
    return ECC_controlAmplitude(deviceHandle, axis, Pointer.getPeer(amplitude), set);
  }
  @Convention(Convention.Style.StdCall)
  protected native static int ECC_controlAmplitude(int deviceHandle, int axis, @Ptr long amplitude, int set);


  /**
   * @brief Control frequency<br>
   *        <br>
   *        Controls the frequency of the actuator signal.<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @param axis
   *          Number of the axis to be configured<br>
   * @param frequency
   *          Frequency in mHz<br>
   * @param set
   *          1: Send the supplied values to the controller<br>
   *          0: Ignore input; only retreive the results<br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_controlFrequency(Int32, Int32, Int32*, Bln32)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:211</i>
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_controlFrequency(int deviceHandle, int axis, Pointer<Integer> frequency, int set) {
    return ECC_controlFrequency(deviceHandle, axis, Pointer.getPeer(frequency), set);
  }
  @Convention(Convention.Style.StdCall)
  protected native static int ECC_controlFrequency(int deviceHandle, int axis, @Ptr long frequency, int set);


  /**
   * @brief Control actor selection<br>
   *        <br>
   *        Selects the actor to be used on selected axis from actor presets<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @param axis
   *          Number of the axis to be configured<br>
   * @param actor
   *          Actor selection [0..255]<br>
   * @param set
   *          1: Send the supplied values to the controller<br>
   *          0: Ignore input; only retreive the results<br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_controlActorSelection(Int32, Int32, Int32*, Bln32)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:228</i>
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_controlActorSelection(int deviceHandle, int axis, Pointer<Integer> actor, int set) {
    return ECC_controlActorSelection(deviceHandle, axis, Pointer.getPeer(actor), set);
  }
  @Convention(Convention.Style.StdCall)
  protected native static int ECC_controlActorSelection(int deviceHandle, int axis, @Ptr long actor, int set);


  /**
   * @brief Get actor name<br>
   *        <br>
   *        Get the name of actual selected actor<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @param axis
   *          Number of the axis to be configured<br>
   * @param name
   *          Name of the actor coded as NULL-terminated c-string. User must
   *          provide at least 20 bytes allocated memory.<br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_getActorName(Int32, Int32, char*)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:242</i>
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_getActorName(int deviceHandle, int axis, Pointer<Byte> name) {
    return ECC_getActorName(deviceHandle, axis, Pointer.getPeer(name));
  }
  @Convention(Convention.Style.StdCall)
  protected native static int ECC_getActorName(int deviceHandle, int axis, @Ptr long name);


  /**
   * @brief Get actor type<br>
   *        <br>
   *        Get the type of actual selected actor<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @param axis
   *          Number of the axis to be configured<br>
   * @param type
   *          Type of the actor. See @ref ECC_actorType<br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_getActorType(Int32, Int32, ECC_actorType*)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:257</i>
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_getActorType(int deviceHandle, int axis, Pointer<IntValuedEnum<EccLibrary.ECC_actorType>> type)
  {
    return ECC_getActorType(deviceHandle, axis, Pointer.getPeer(type));
  }
  @Convention(Convention.Style.StdCall)
  protected native static int ECC_getActorType(int deviceHandle, int axis, @Ptr long type);

  /**
   * @brief Save params<br>
   *        <br>
   *        Saves user parameters to persistent flash in controller. Parameters
   *        that will be saved are amplitude, <br>
   *        frequency and actor selection of each axis.<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_setSaveParams(Int32)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:271</i>
   */
  @Convention(Convention.Style.StdCall)
  public static native int ECC_setSaveParams(int deviceHandle);


  /**
   * @brief Writing flash status<br>
   *        <br>
   *        Retrieves the status of writing to flash. Indicates whether a write
   *        access<br>
   *        to the flash is performing.<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @param writing
   *          status<br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_getStatusFlash(Int32, Bln32*)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:284</i>
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_getStatusFlash(int deviceHandle, Pointer<Integer> writing) {
    return ECC_getStatusFlash(deviceHandle, Pointer.getPeer(writing));
  }
  @Convention(Convention.Style.StdCall)
  protected native static int ECC_getStatusFlash(int deviceHandle, @Ptr long writing);


  /**
   * @brief Reset position<br>
   *        <br>
   *        Resets the actual position to zero and marks the reference position
   *        as invalid.<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @param axis
   *          Number of the axis to be configured<br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_setReset(Int32, Int32)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:297</i>
   */
  @Convention(Convention.Style.StdCall)
  public static native int ECC_setReset(int deviceHandle, int axis);


  /**
   * @brief Control actor approach<br>
   *        <br>
   *        Controls the approach of the actor to the target position<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @param axis
   *          Number of the axis to be configured<br>
   * @param enable
   *          Enables/ disables the approach<br>
   * @param set
   *          1: Send the supplied values to the controller<br>
   *          0: Ignore input; only retreive the results<br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_controlMove(Int32, Int32, Bln32*, Bln32)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:312</i>
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_controlMove(int deviceHandle, int axis, Pointer<Integer> enable, int set) {
    return ECC_controlMove(deviceHandle, axis, Pointer.getPeer(enable), set);
  }

  @Convention(Convention.Style.StdCall)
  protected native static int ECC_controlMove(int deviceHandle, int axis, @Ptr long enable, int set);

  /**
   * @brief Single step<br>
   *        <br>
   *        Triggers a single step in desired direction.<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @param axis
   *          Number of the axis to be configured<br>
   * @param backward
   *          Selects the desired direction. False triggers a forward step,<br>
   *          true a backward step.<br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_setSingleStep(Int32, Int32, Bln32)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:328</i>
   */
  @Convention(Convention.Style.StdCall)
  public static native int ECC_setSingleStep(int deviceHandle, int axis, int backward);


  /**
   * @brief Control continous movement forward<br>
   *        <br>
   *        Controls continous movement in forward direction. If enabled a
   *        potential present movement<br>
   *        in the opposite direction is stopped. The parameter "false" stops
   *        all movement of the axis regardless<br>
   *        its direction.<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @param axis
   *          Number of the axis to be configured<br>
   * @param enable
   *          Enables/ disables the movement<br>
   * @param set
   *          1: Send the supplied values to the controller<br>
   *          0: Ignore input; only retreive the results<br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_controlContinousFwd(Int32, Int32, Bln32*, Bln32)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:346</i>
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_controlContinousFwd(int deviceHandle, int axis, Pointer<Integer> enable, int set) {
    return ECC_controlContinousFwd(deviceHandle, axis, Pointer.getPeer(enable), set);
  }
  @Convention(Convention.Style.StdCall)
  protected native static int ECC_controlContinousFwd(int deviceHandle, int axis, @Ptr long enable, int set);


  /**
   * @brief Control continous movement backward<br>
   *        <br>
   *        Controls continous movement in backward direction. If enabled a
   *        potential present movement<br>
   *        in the opposite direction is stopped. The parameter "false" stops
   *        all movement of the axis regardless<br>
   *        its direction.<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @param axis
   *          Number of the axis to be configured<br>
   * @param enable
   *          Enables/ disables the movement<br>
   * @param set
   *          1: Send the supplied values to the controller<br>
   *          0: Ignore input; only retreive the results<br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_controlContinousBkwd(Int32, Int32, Bln32*, Bln32)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:366</i>
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_controlContinousBkwd(int deviceHandle, int axis, Pointer<Integer> enable, int set) {
    return ECC_controlContinousBkwd(deviceHandle, axis, Pointer.getPeer(enable), set);
  }
  @Convention(Convention.Style.StdCall)
  protected native static int ECC_controlContinousBkwd(int deviceHandle, int axis, @Ptr long enable, int set);


  /**
   * @brief Control target position<br>
   *        <br>
   *        Controls the target position for the approach function, see @ref
   *        ECC_controlMove .<br>
   *        For linear type actors the position is defined in nm for goniometer
   *        an rotator type<br>
   *        actors it is \u00b5\u00b0.<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @param axis
   *          Number of the axis to be configured<br>
   * @param target
   *          Target position in nm or \u00b5\u00b0 depending on actor type.<br>
   * @param set
   *          1: Send the supplied values to the controller<br>
   *          0: Ignore input; only retreive the results<br>
   * @return Result of function<br> (RESULT OF THE FUNCTION?! REALLY?! IN THE INTEGER FORM???? AND 1 - is arrived or what???)
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_controlTargetPosition(Int32, Int32, Int32*, Bln32)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:384</i>
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_controlTargetPosition(int deviceHandle, int axis, Pointer<Integer> target, int set) {
    return ECC_controlTargetPosition(deviceHandle, axis, Pointer.getPeer(target), set);
  }

  @Convention(Convention.Style.StdCall)
  protected native static int ECC_controlTargetPosition(int deviceHandle, int axis, @Ptr long target, int set);


  /**
   * @brief Reference status<br>
   *        <br>
   *        Retrieves the status of the reference position. It may be valid or
   *        invalid.<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @param axis
   *          Number of the axis to be configured<br>
   * @param valid
   *          Status of the reference position.<br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_getStatusReference(Int32, Int32, Bln32*)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:400</i>
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_getStatusReference(int deviceHandle, int axis, Pointer<Integer> valid) {
    return ECC_getStatusReference(deviceHandle, axis, Pointer.getPeer(valid));
  }

  @Convention(Convention.Style.StdCall)
  protected native static int ECC_getStatusReference(int deviceHandle, int axis, @Ptr long valid);

  /**
   * @brief Moving status<br>
   *        <br>
   *        Retrieves the status of the output stage. Moving means the actor is
   *        actively driven by the output stage<br>
   *        either for approaching or continuous/single stepping and the output
   *        is active. Pending means the output<br>
   *        stage is driving but the output is deactivted i.e. by EOT or
   *        ECC_controlOutput.<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @param axis
   *          Number of the axis to be configured<br>
   * @param moving
   *          Moving status, 0: Idle; 1: Moving; 2: Pending<br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_getStatusMoving(Int32, Int32, Int32*)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:417</i>
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_getStatusMoving(int deviceHandle, int axis, Pointer<Integer> moving) {
    return ECC_getStatusMoving(deviceHandle, axis, Pointer.getPeer(moving));
  }

  @Convention(Convention.Style.StdCall)
  protected native static int ECC_getStatusMoving(int deviceHandle, int axis, @Ptr long moving);

  /**
   * @brief Error status<br>
   *        <br>
   *        Retrieves the error status. Indicates a sensor malfunction.<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @param axis
   *          Number of the axis to be configured<br>
   * @param error
   *          Error status. "True" means the occurrence of an error.<br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_getStatusError(Int32, Int32, Bln32*)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:432</i>
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_getStatusError(int deviceHandle,
                                       int axis,
                                       Pointer<Integer> error)
  {
    return ECC_getStatusError(deviceHandle, axis, Pointer.getPeer(error));
  }

  @Convention(Convention.Style.StdCall)
  protected native static int ECC_getStatusError(int deviceHandle, int axis, @Ptr long error);

  /**
   * @brief Connected status<br>
   *        <br>
   *        Retrieves the connected status. Indicates whether an actor is
   *        eletrically connected<br>
   *        to the controller.<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @param axis
   *          Number of the axis to be configured<br>
   * @param connected
   *          status<br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_getStatusConnected(Int32, Int32, Bln32*)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:448</i>
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_getStatusConnected(int deviceHandle, int axis, Pointer<Integer> connected) {
    return ECC_getStatusConnected(deviceHandle, axis, Pointer.getPeer(connected));
  }
  @Convention(Convention.Style.StdCall)
  protected native static int ECC_getStatusConnected(int deviceHandle, int axis, @Ptr long connected);


  /**
   * @brief Reference position<br>
   *        <br>
   *        Retrieves the reference position. See @ref ECC_getStatusReference
   *        for <br>
   *        determining the validity.<br>
   *        For linear type actors the position is defined in nm for goniometer
   *        an rotator type<br>
   *        actors it is \u00b5\u00b0.<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @param axis
   *          Number of the axis to be configured<br>
   * @param reference
   *          Reference position in nm or \u00b5\u00b0 depending on actor
   *          type.<br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_getReferencePosition(Int32, Int32, Int32*)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:467</i>
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_getReferencePosition(int deviceHandle, int axis, Pointer<Integer> reference) {
    return ECC_getReferencePosition(deviceHandle, axis, Pointer.getPeer(reference));
  }
  @Convention(Convention.Style.StdCall)
  protected native static int ECC_getReferencePosition(int deviceHandle, int axis, @Ptr long reference);


  /**
   * @brief Actor position<br>
   *        <br>
   *        Retrieves the current actor position.<br>
   *        For linear type actors the position is defined in nm for goniometer
   *        an rotator type<br>
   *        actors it is \u00b5\u00b0.<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @param axis
   *          Number of the axis to be configured<br>
   * @param position
   *          Actor position in nm or \u00b5\u00b0 depending on actor type.<br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_getPosition(Int32, Int32, Int32*)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:484</i>
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_getPosition(int deviceHandle, int axis, Pointer<Integer> position) {
    return ECC_getPosition(deviceHandle, axis, Pointer.getPeer(position));
  }

  @Convention(Convention.Style.StdCall)
  protected native static int ECC_getPosition(int deviceHandle, int axis, @Ptr long position);

  /**
   * @brief Reference Auto Update<br>
   *        <br>
   *        When set, every time the reference marking is hit the reference
   *        position<br>
   *        will be updated. When this function is disabled, the reference
   *        marking will<br>
   *        be considered only the first time and after then ignored.<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @param axis
   *          Number of the axis to be configured<br>
   * @param enable
   *          enable/disable auto update<br>
   * @param set
   *          1: Send the supplied values to the controller<br>
   *          0: Ignore input; only retreive the results<br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_controlReferenceAutoUpdate(Int32, Int32, Bln32*, Bln32)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:502</i>
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_controlReferenceAutoUpdate(int deviceHandle, int axis, Pointer<Integer> enable, int set)
  {
    return ECC_controlReferenceAutoUpdate(deviceHandle, axis, Pointer.getPeer(enable), set);
  }

  @Convention(Convention.Style.StdCall)
  protected native static int ECC_controlReferenceAutoUpdate(int deviceHandle, int axis, @Ptr long enable, int set);

  /**
   * @brief Auto Reset<br>
   *        <br>
   *        Resets the position for every time the reference position is
   *        detected.<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @param axis
   *          Number of the axis to be configured<br>
   * @param enable
   *          enables/ disable functionality<br>
   * @param set
   *          1: Send the supplied values to the controller<br>
   *          0: Ignore input; only retreive the results<br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_controlAutoReset(Int32, Int32, Bln32*, Bln32)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:519</i>
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_controlAutoReset(int deviceHandle, int axis, Pointer<Integer> enable, int set)
  {
    return ECC_controlAutoReset(deviceHandle, axis, Pointer.getPeer(enable), set);
  }
  @Convention(Convention.Style.StdCall)
  protected native static int ECC_controlAutoReset(int deviceHandle, int axis, @Ptr long enable, int set);

  /**
   * @brief Target Range<br>
   *        <br>
   *        Defines the range around the target position in which the flag
   *        target status<br>
   *        become active.<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @param axis
   *          Number of the axis to be configured<br>
   * @param range
   *          range in nm or \u00b5\u00b0 depending on actor type.<br>
   * @param set
   *          1: Send the supplied values to the controller<br>
   *          0: Ignore input; only retreive the results<br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_controlTargetRange(Int32, Int32, Int32*, Bln32)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:537</i>
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_controlTargetRange(int deviceHandle, int axis, Pointer<Integer> range, int set) {
    return ECC_controlTargetRange(deviceHandle, axis, Pointer.getPeer(range), set);
  }
  @Convention(Convention.Style.StdCall)
  protected native static int ECC_controlTargetRange(int deviceHandle,
                                                     int axis,
                                                     @Ptr long range,
                                                     int set);

  /**
   * @brief Target status<br>
   *        <br>
   *        Retrieves the target status. Indicates whether the actual position
   *        is within<br>
   *        the target range.<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @param axis
   *          Number of the axis to be configured<br>
   * @param target
   *          actual position is within target range<br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_getStatusTargetRange(Int32, Int32, Bln32*)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:552</i>
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_getStatusTargetRange(int deviceHandle, int axis, Pointer<Integer> target) {
    return ECC_getStatusTargetRange(deviceHandle, axis, Pointer.getPeer(target));
  }
  @Convention(Convention.Style.StdCall)
  protected native static int ECC_getStatusTargetRange(int deviceHandle, int axis, @Ptr long target);


  /**
   * @brief Firmware version<br>
   *        <br>
   *        Retrieves the version of actual firmware<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @param version
   *          version number<br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_getFirmwareVersion(Int32, Int32*)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:565</i>
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_getFirmwareVersion(int deviceHandle, Pointer<Integer> version) {
    return ECC_getFirmwareVersion(deviceHandle, Pointer.getPeer(version));
  }
  @Convention(Convention.Style.StdCall)
  protected native static int ECC_getFirmwareVersion(int deviceHandle,@Ptr long version);


  /**
   * @brief Device id<br>
   *        <br>
   *        Sets and retrieve the device identifier. A set will save the<br>
   *        id persistent in flash of the device.<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @param id
   *          iud of the device.<br>
   * @param set
   *          1: Send the supplied values to the controller<br>
   *          0: Ignore input; only retreive the results<br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_controlDeviceId(Int32, Int32*, Bln32)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:580</i>
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_controlDeviceId(int deviceHandle, Pointer<Integer> id, int set) {
    return ECC_controlDeviceId(deviceHandle, Pointer.getPeer(id), set);
  }
  @Convention(Convention.Style.StdCall)
  protected native static int ECC_controlDeviceId(int deviceHandle, @Ptr long id, int set);


  /**
   * @brief EOT - END OF TRAVEL - status forward<br>
   *        <br>
   *        Retrieves the status of the end of travel (EOT) detection in forward
   *        direction.<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @param axis
   *          Number of the axis to be configured<br>
   * @param EotDetected
   *          status<br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_getStatusEotFwd(Int32, Int32, Bln32*)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:594</i>
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_getStatusEotFwd(int deviceHandle, int axis, Pointer<Integer> EotDetected) {
    return ECC_getStatusEotFwd(deviceHandle, axis, Pointer.getPeer(EotDetected));
  }
  @Convention(Convention.Style.StdCall)
  protected native static int ECC_getStatusEotFwd(int deviceHandle, int axis, @Ptr long EotDetected);


  /**
   * @brief EOT - END OF TRAVEL - status backward<br>
   *        <br>
   *        Retrieves the status of the end of travel (EOT) detection in
   *        backward direction.<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @param axis
   *          Number of the axis to be configured<br>
   * @param EotDetected
   *          status<br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_getStatusEotBkwd(Int32, Int32, Bln32*)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:607</i>
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_getStatusEotBkwd(int deviceHandle, int axis, Pointer<Integer> EotDetected) {
    return ECC_getStatusEotBkwd(deviceHandle, axis, Pointer.getPeer(EotDetected));
  }
  @Convention(Convention.Style.StdCall)
  protected native static int ECC_getStatusEotBkwd(int deviceHandle, int axis, @Ptr long EotDetected);


  /**
   * @brief Output deactivate on EOT<br>
   *        <br>
   *        Defines the behavior of the output on EOT. If enabled, the output of
   *        the axis will be deactivated on positive EOT detection.<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @param axis
   *          Number of the axis to be configured<br>
   * @param enable
   *          true: Output will be deactiveted on EOT.<br>
   *          false: Output stays active on EOT<br>
   * @param set
   *          1: Send the supplied values to the controller<br>
   *          0: Ignore input; only retrieve the results<br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_controlEotOutputDeactive(Int32, Int32, Bln32*, Bln32)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:623</i>
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_controlEotOutputDeactive(int deviceHandle, int axis, Pointer<Integer> enable, int set) {
    return ECC_controlEotOutputDeactive(deviceHandle, axis, Pointer.getPeer(enable), set);
  }
  @Convention(Convention.Style.StdCall)
  protected native static int ECC_controlEotOutputDeactive(int deviceHandle, int axis, @Ptr long enable, int set);


  /**
   * @brief Fixed output voltage<br>
   *        <br>
   *        Controls the DC level on the output.<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @param axis
   *          Number of the axis to be configured<br>
   * @param voltage
   *          Output voltage in \u00b5V<br>
   * @param set
   *          1: Send the supplied values to the controller<br>
   *          0: Ignore input; only retreive the results<br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_controlFixOutputVoltage(Int32, Int32, Int32*, Bln32)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:642</i>
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_controlFixOutputVoltage(int deviceHandle, int axis, Pointer<Integer> voltage, int set) {
    return ECC_controlFixOutputVoltage(deviceHandle, axis, Pointer.getPeer(voltage), set);
  }
  @Convention(Convention.Style.StdCall)
  protected native static int ECC_controlFixOutputVoltage(int deviceHandle, int axis, @Ptr long voltage, int set);


  /**
   * @brief Trigger input enable<br>
   *        <br>
   *        Controls the input trigger for steps.<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @param axis
   *          Number of the axis to be configured<br>
   * @param enable
   *          true: External trigger enabled<br>
   *          false: External trigger disabled<br>
   * @param set
   *          1: Send the supplied values to the controller<br>
   *          0: Ignore input; only retreive the results<br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_controlExtTrigger(Int32, Int32, Bln32*, Bln32)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:661</i>
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_controlExtTrigger(int deviceHandle,
                                          int axis,
                                          Pointer<Integer> enable,
                                          int set)
  {
    return ECC_controlExtTrigger(deviceHandle,
                                 axis,
                                 Pointer.getPeer(enable),
                                 set);
  }

  @Convention(Convention.Style.StdCall)
  protected native static int ECC_controlExtTrigger(int deviceHandle,
                                                    int axis,
                                                    @Ptr long enable,
                                                    int set);

  /**
   * @brief AQuadB input enable<br>
   *        <br>
   *        Controls the AQuadB input for setpoint parameter.<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @param axis
   *          Number of the axis to be configured<br>
   * @param enable
   *          true: AQuadB input enabled<br>
   *          false: AQuadB input disabled<br>
   * @param set
   *          1: Send the supplied values to the controller<br>
   *          0: Ignore input; only retreive the results<br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_controlAQuadBIn(Int32, Int32, Bln32*, Bln32)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:680</i>
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_controlAQuadBIn(int deviceHandle,
                                        int axis,
                                        Pointer<Integer> enable,
                                        int set)
  {
    return ECC_controlAQuadBIn(deviceHandle,
                               axis,
                               Pointer.getPeer(enable),
                               set);
  }

  @Convention(Convention.Style.StdCall)
  protected native static int ECC_controlAQuadBIn(int deviceHandle,
                                                  int axis,
                                                  @Ptr long enable,
                                                  int set);

  /**
   * @brief AQuadB input resolution<br>
   *        <br>
   *        Controls the AQuadB input resolution for setpoint parameter.<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @param axis
   *          Number of the axis to be configured<br>
   * @param resolution
   *          resolution in nm<br>
   * @param set
   *          1: Send the supplied values to the controller<br>
   *          0: Ignore input; only retreive the results<br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_controlAQuadBInResolution(Int32, Int32, Int32*, Bln32)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:696</i>
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_controlAQuadBInResolution(int deviceHandle,
                                                  int axis,
                                                  Pointer<Integer> resolution,
                                                  int set)
  {
    return ECC_controlAQuadBInResolution(deviceHandle,
                                         axis,
                                         Pointer.getPeer(resolution),
                                         set);
  }

  @Convention(Convention.Style.StdCall)
  protected native static int ECC_controlAQuadBInResolution(int deviceHandle,
                                                            int axis,
                                                            @Ptr long resolution,
                                                            int set);

  /**
   * @brief AQuadB output enable<br>
   *        <br>
   *        Controls the AQuadB output for position indication.<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @param axis
   *          Number of the axis to be configured<br>
   * @param enable
   *          true: AQuadB output enabled<br>
   *          false: AQuadB output disabled<br>
   * @param set
   *          1: Send the supplied values to the controller<br>
   *          0: Ignore input; only retreive the results<br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_controlAQuadBOut(Int32, Int32, Bln32*, Bln32)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:714</i>
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_controlAQuadBOut(int deviceHandle,
                                         int axis,
                                         Pointer<Integer> enable,
                                         int set)
  {
    return ECC_controlAQuadBOut(deviceHandle,
                                axis,
                                Pointer.getPeer(enable),
                                set);
  }

  @Convention(Convention.Style.StdCall)
  protected native static int ECC_controlAQuadBOut(int deviceHandle,
                                                   int axis,
                                                   @Ptr long enable,
                                                   int set);

  /**
   * @brief AQuadB output resolution<br>
   *        <br>
   *        Controls the AQuadB output resolution for position indication.<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @param axis
   *          Number of the axis to be configured<br>
   * @param resolution
   *          resolution in nm<br>
   * @param set
   *          1: Send the supplied values to the controller<br>
   *          0: Ignore input; only retreive the results<br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_controlAQuadBOutResolution(Int32, Int32, Int32*, Bln32)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:730</i>
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_controlAQuadBOutResolution(int deviceHandle,
                                                   int axis,
                                                   Pointer<Integer> resolution,
                                                   int set)
  {
    return ECC_controlAQuadBOutResolution(deviceHandle,
                                          axis,
                                          Pointer.getPeer(resolution),
                                          set);
  }

  @Convention(Convention.Style.StdCall)
  protected native static int ECC_controlAQuadBOutResolution(int deviceHandle,
                                                             int axis,
                                                             @Ptr long resolution,
                                                             int set);

  /**
   * @brief AQuadB output clock<br>
   *        <br>
   *        Controls the clock for AQuadB output.<br>
   *        <br>
   * @param deviceHandle
   *          Handle of device<br>
   * @param axis
   *          Number of the axis to be configured<br>
   * @param clock
   *          Clock in multiples of 20ns. Minimum 2 (40ns), maximum 65535
   *          (1,310700ms)<br>
   * @param set
   *          1: Send the supplied values to the controller<br>
   *          0: Ignore input; only retreive the results<br>
   * @return Result of function<br>
   *         Original signature :
   *         <code>__attribute__((dllimport)) Int32 ECC_controlAQuadBOutClock(Int32, Int32, Int32*, Bln32)</code><br>
   *         <i>native declaration : lib\ecc100\ecc.h:746</i>
   */
  @Convention(Convention.Style.StdCall)
  public static int ECC_controlAQuadBOutClock(int deviceHandle,
                                              int axis,
                                              Pointer<Integer> clock,
                                              int set)
  {
    return ECC_controlAQuadBOutClock(deviceHandle,
                                     axis,
                                     Pointer.getPeer(clock),
                                     set);
  }

  @Convention(Convention.Style.StdCall)
  protected native static int ECC_controlAQuadBOutClock(int deviceHandle,
                                                        int axis,
                                                        @Ptr long clock,
                                                        int set);
}
